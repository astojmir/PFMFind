/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.19
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON

#include "Python.h"

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;	
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(const char *)     SWIG_TypeName(const swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;	
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  if (next) next->prev = head;  /**/
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      s->prev = ty;  /**/
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Return the name associated with this type */
SWIGRUNTIME(const char *)
SWIG_TypeName(const swig_type_info *ty) {
  return ty->name;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata == clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4
#define SWIG_PY_BINARY  5

/* Flags for pointer conversion */

#define SWIG_POINTER_EXCEPTION     0x1
#define SWIG_POINTER_DISOWN        0x2

/* Exception handling in wrappers */
#define SWIG_fail   goto fail

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

#ifdef SWIG_NOINCLUDE

SWIGEXPORT(PyObject *)        SWIG_newvarlink(void);
SWIGEXPORT(void)              SWIG_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGEXPORT(int)               SWIG_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGEXPORT(int)               SWIG_ConvertPacked(PyObject *, void *, int sz, swig_type_info *, int);
SWIGEXPORT(char *)            SWIG_PackData(char *c, void *, int);
SWIGEXPORT(char *)            SWIG_UnpackData(char *c, void *, int);
SWIGEXPORT(PyObject *)        SWIG_NewPointerObj(void *, swig_type_info *,int own);
SWIGEXPORT(PyObject *)        SWIG_NewPackedObj(void *, int sz, swig_type_info *);
SWIGEXPORT(void)              SWIG_InstallConstants(PyObject *d, swig_const_info constants[]);
#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  (char *)"swigvarlink",                      /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;
  static PyObject *SWIG_this = 0;
  int    newref = 0;
  PyObject  *pyobj = 0;

  if (!obj) return 0;
  if (obj == Py_None) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  }  
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_FromString("this");
    pyobj = obj;
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) { Py_DECREF(obj); }
      return 0;
    } else {
      if (newref) { Py_DECREF(obj); }
      goto type_error;
    }
  }
  c++;
  c = SWIG_UnpackData(c,ptr,sizeof(void *));
  if (newref) { Py_DECREF(obj); }
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*) *ptr);
  }

  if ((pyobj) && (flags & SWIG_POINTER_DISOWN)) {
      PyObject *zero = PyInt_FromLong(0);
      PyObject_SetAttrString(pyobj,(char*)"thisown",zero);
      Py_DECREF(zero);
  }
  return 0;

type_error:
  if (flags & SWIG_POINTER_EXCEPTION) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Convert a packed value value */
SWIGRUNTIME(int)
SWIG_ConvertPacked(PyObject *obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;

  if ((!obj) || (!PyString_Check(obj))) goto type_error;
  c = PyString_AsString(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c,ptr,sz);
  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
  }
  return 0;

type_error:

  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type, int own) {
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, (char *) type->name, NULL);
#else
  {
    char result[1024];
    char *r = result;
    *(r++) = '_';
    r = SWIG_PackData(r,&ptr,sizeof(void *));
    strcpy(r,type->name);
    robj = PyString_FromString(result);
  }
#endif
  if (!robj || (robj == Py_None)) return robj;
  if (type->clientdata) {
    PyObject *inst;
    PyObject *args = Py_BuildValue((char*)"(O)", robj);
    Py_DECREF(robj);
    inst = PyObject_CallObject((PyObject *) type->clientdata, args);
    Py_DECREF(args);
    if (inst) {
      if (own) {
	PyObject *n = PyInt_FromLong(1);
	PyObject_SetAttrString(inst,(char*)"thisown",n);
	Py_DECREF(n);
      }
      robj = inst;
    }
  }
  return robj;
}

SWIGRUNTIME(PyObject *)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,type->name);
  return PyString_FromString(result);
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype,0);
      break;
    case SWIG_PY_BINARY:
      obj = SWIG_NewPackedObj(constants[i].pvalue, constants[i].lvalue, *(constants[i].ptype));
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

#ifdef __cplusplus
}
#endif








/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_FILE swig_types[0] 
#define  SWIGTYPE_p_index swig_types[1] 
#define  SWIGTYPE_p_fgen swig_types[2] 
#define  SWIGTYPE_p_seqn swig_types[3] 
#define  SWIGTYPE_p_smatrix swig_types[4] 
#define  SWIGTYPE_p_db swig_types[5] 
#define  SWIGTYPE_p_hit swig_types[6] 
#define  SWIGTYPE_p_hit_list swig_types[7] 
#define  SWIGTYPE_p_ptable swig_types[8] 
static swig_type_info *swig_types[10];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= _FS.so
  ------------------------------------------------*/
#define SWIG_init    init_FS

#define SWIG_name    "_FS"

#include "misclib.h"
#include "bioseq.h"
#include "fastadb.h"
#include "partition.h"
#include "smatrix.h"
#include "pmatrix.h"
#include "randseq.h"
#include "hit_list.h"
#include "FSindex.h"

EXCEPTION FSexcept_array[1];
EXCEPTION *except;

struct exception_context the_exception_context[1];

 typedef FS_PARTITION_t ptable;
 typedef SEQUENCE_DB db;
 typedef SCORE_MATRIX_t smatrix;
 typedef SEQ_HIT_t hit;
 typedef HIT_LIST_t hit_list;
 typedef FSINDX index;


  typedef struct {
    BIOSEQ *seq;
    int free_flag;
    int defline_flag;
  } seqn;

  int seqn_len_get(seqn *self) {
    return self->seq->len;
  }
  const char *seqn_seq_get(seqn *self) {
    return self->seq->start;
  }
  const char *seqn_defline_get(seqn *self) {
    if (!self->defline_flag || self->seq->id.defline == NULL)
      return "";
    else 
      return self->seq->id.defline;
  }

  int ptable_no_pttn_get(ptable *self) {
    return FS_PARTITION_get_no_partitions(self);
  }

  ptable *ptable_read(FILE *stream) {
    return FS_PARTITION_read(stream);
  }

  typedef struct {
    SEQ_GENERATOR_t *sgen;
    char *heap;
    ULINT max_len;
    seqn *Fseq;
  } fgen;

  index *index_load(const char *filename) {
   return FS_INDEX_load(filename);
  }

  hit_list *sscan_qd_srch(db *s_db, const char *matrix, 
			  seqn *query, ULINT D_cutoff) {
    return SSCAN_QD_search(s_db, matrix, query->seq, 
			  D_cutoff);
  }
 int sscan_has_nbr(db *s_db, smatrix *D, ptable *pt, 
		   seqn *query, ULINT D_cutoff) {
   return SSCAN_has_neighbour(s_db, D, pt, query->seq, D_cutoff);
 }




seqn *new_seqn(char *sqn,char *defline){
    seqn *Fseq;
    
    Fseq = mallocec(sizeof(seqn));
    Fseq->seq = mallocec(sizeof(BIOSEQ));
    Fseq->seq->start = sqn;
    Fseq->seq->len = strlen(sqn);
    Fseq->seq->id.defline = defline;
    Fseq->free_flag = 1;
    Fseq->defline_flag = 1;
    return Fseq;
  }
void delete_seqn(seqn *self){
    if (self->free_flag)
      free(self->seq);
    free(self);
  }
char const *seqn___str__(seqn *self){
    return self->seq->start;
  }
db *new_db(char const *db_name){
    fastadb_arg fastadb_argt[3];
    fastadb_argv_t fastadb_argv[3];

    fastadb_argt[0] = ACCESS_TYPE;
    fastadb_argt[1] = RETREIVE_DEFLINES;
    fastadb_argt[2] = NONE;
    fastadb_argv[0].access_type = MEMORY;
    fastadb_argv[1].retrieve_deflines = YES;

    return fastadb_open(db_name, fastadb_argt, fastadb_argv);
  }
void delete_db(db *self){
    fastadb_close(self);
  }
char *db___str__(db *self){
    char *s;
    ULINT len;
    len = fastadb_count_Ffrags(self, 1);
    s = mallocec(strlen(self->db_name)+7+20+9+10+12);
    sprintf(s,"File: %s\nLength: %d\nSequences: %d",
	    self->db_name, len, self->no_seq);
    return s;
  }
seqn *db_get_seq(db *self,ULINT seq_no){
    seqn *Fseq;
    Fseq = mallocec(sizeof(seqn));
    Fseq->free_flag = 0;
    Fseq->defline_flag = 1;

    fastadb_get_seq(self, seq_no, &(Fseq->seq));
    return Fseq;
  }
void db_init_frags(db *self,ULINT min_len,ULINT max_len){
    fastadb_init_frags(self, min_len, max_len);
  }
void db_clear_frags(db *self){
     fastadb_clear_frags(self);
  }
ULINT db_get_nofrags(db *self,ULINT min_len,ULINT max_len){
    ULINT n = 0;

    fastadb_get_nofrags(self, &n, min_len, max_len);
    return n;
  }
seqn *db_get_frag(db *self,ULINT n,ULINT min_len,ULINT max_len){
    seqn *Fseq;
    BIOSEQ *ts;

    Fseq = mallocec(sizeof(seqn));
    Fseq->free_flag = 1;
    Fseq->defline_flag = 0;

    fastadb_get_frag(self, ts, n, min_len, max_len);
    Fseq->seq = bioseq_copy(ts);
    return Fseq;
  }
void db_init_Ffrags(db *self,ULINT len){
    fastadb_init_Ffrags(self, len);
  }
ULINT db_count_Ffrags(db *self,ULINT len){
    ULINT c;
    c = fastadb_count_Ffrags(self, len);
    return c;
  }
seqn *db_get_Ffrag(db *self,ULINT len,ULINT n){
    seqn *Fseq;
    BIOSEQ *ts;
    Fseq = mallocec(sizeof(seqn));
    Fseq->free_flag = 1;
    Fseq->defline_flag = 0;

    fastadb_get_Ffrag(self, len, ts, n);
    Fseq->seq = bioseq_copy(ts);
    return Fseq;
  }
ptable *new_ptable(char const *alphabet){
    return FS_PARTITION_create(alphabet, '#');
  }
void delete_ptable(ptable *self){
    FS_PARTITION_destroy(self);
  }
void ptable_print_table(ptable *self,FILE *stream){
    FS_PARTITION_print(self, stream);
  }
char *ptable___str__(ptable *self){
    return self->alphabet;
  }
int ptable_get_pttn(ptable *self,char letter){
    return FS_PARTITION_get_pttn(self, letter);
  }
int ptable_get_posn(ptable *self,char letter){
    return FS_PARTITION_get_pos(self, letter);
  }
int ptable_get_pttn_size(ptable *self,int pttn){
    return FS_PARTITION_get_size(self, pttn);
  }
int ptable_get_poffset(ptable *self,int pttn){
    return FS_PARTITION_get_poffset(self, pttn);
  }
char ptable_get_letter(ptable *self,int pttn,int posn){
    return (char) FS_PARTITION_get_letter(self, pttn, posn);
  }
int ptable_check_seqn(ptable *self,seqn *Fseq){
    return FS_PARTITION_check_seq(Fseq->seq, self);
  }
void ptable_write(ptable *self,FILE *stream){
    FS_PARTITION_write(self, stream);
  }
seqn *ptable_seqn2reduced(ptable *self,seqn *Fseq){
    char c;
    int i;
    int j=0;
    char *newseq = mallocec(Fseq->seq->len+1);
    seqn *Rseq;

    for (j=0; j < Fseq->seq->len; j++)
      {
	c = Fseq->seq->start[j];
	i = self->partition_table[c & A_SIZE_MASK];
	if (i == -1) 
	  {
	    free(newseq);
	    Throw FSexcept(BAD_ARGS, "Sequence contains"
			   " letters not in ptable.\n");
	  }
	sprintf(newseq+j, "%1.1d", i);
      }
    newseq[j]='\0';

    Rseq = mallocec(sizeof(seqn));
    Rseq->seq = mallocec(sizeof(BIOSEQ));
    Rseq->seq->start = newseq;
    Rseq->seq->len = Fseq->seq->len;
    Rseq->seq->id.defline = Fseq->seq->id.defline;
    Rseq->free_flag = 1;
    Rseq->defline_flag = 1;
    return Rseq;
  }
extern ptable *ptable_read(FILE *);
fgen *new_fgen(char const *filename,ptable *ptable,ULINT max_len){
    fgen *FG = mallocec(sizeof(fgen));
    FG->sgen = SEQ_GENERATOR_create(filename, ptable);
    FG->max_len = max_len;
    FG->heap = mallocec(max_len+1);
    FG->Fseq = mallocec(sizeof(seqn));
    FG->Fseq->free_flag = 0;
    FG->Fseq->defline_flag = 1;
    FG->Fseq->seq = mallocec(sizeof(BIOSEQ));
    FG->Fseq->seq->id.defline = "Random Sequence";
    return FG;
  }
void delete_fgen(fgen *self){
    SEQ_GENERATOR_destroy(self->sgen);
    free(self->heap);
    free(self->Fseq->seq);
    free(self->Fseq);
    free(self);
  }
seqn *fgen_rand_seq(fgen *self,ULINT len){
    if (len >= self->max_len) {
      self->max_len = len;
      self->heap = reallocec(self->heap, self->max_len+1);
    }
    SEQ_GENERATOR_rand_seq(self->sgen, self->Fseq->seq, len, 
			   self->heap);
    return self->Fseq;
  }
double fgen_freq(fgen *self,char c){
    int i = c & A_SIZE_MASK;
    if (i==0)
      return ((double) self->sgen->cum_freq[i])/ self->sgen->total_residues;  
    else
      return ((double) (self->sgen->cum_freq[i] - self->sgen->cum_freq[i-1])) /
	self->sgen->total_residues;
  }
smatrix *new_smatrix(char const *filename,ptable *ptable){
    return SCORE_MATRIX_create(filename, ptable);
  }
void delete_smatrix(smatrix *self){
    SCORE_MATRIX_destroy(self);
  }
void smatrix_set_M(smatrix *self,char row,char col,SSINT val){
    SCORE_MATRIX_set_M(self, row, col, val);
  }
void smatrix_set_SS(smatrix *self,char row,SSINT val){
    SCORE_MATRIX_set_SS(self, row, val);
  }
int smatrix_get_M(smatrix *self,char row,char col){
    return SCORE_MATRIX_get_M(self, row, col);
  }
int smatrix_get_pM(smatrix *self,char row,int group){
    return SCORE_MATRIX_get_pM(self, row, group);
  }
int smatrix_get_pMc(smatrix *self,char row){
    return SCORE_MATRIX_get_pMc(self, row);
  }
int smatrix_get_SS(smatrix *self,char row){
    return SCORE_MATRIX_get_SS(self, row);
  }
int smatrix_score(smatrix *self,seqn *query,seqn *subject){
    return SCORE_MATRIX_evaluate(self, query->seq, subject->seq);
  }
void smatrix_print_matrix(smatrix *self,FILE *stream,char const *title){
    SCORE_MATRIX_print(self, stream, title); 
  }
smatrix *smatrix_S2Dmax(smatrix *self){
    return SCORE_MATRIX_S_2_Dmax(self);
  }
smatrix *smatrix_S2Davg(smatrix *self){
    return SCORE_MATRIX_S_2_Davg(self);
  }
smatrix *smatrix_S2Dquasi(smatrix *self){
    return SCORE_MATRIX_S_2_Dquasi(self);
  }
seqn *hit_get_subject(hit *self){
    seqn *Fseq;
    
    Fseq = mallocec(sizeof(seqn));
    Fseq->seq = bioseq_copy(self->subject);
    Fseq->free_flag = 1;
    Fseq->defline_flag = 1;
    return Fseq;
  }
void delete_hit_list(hit_list *self){
    HIT_LIST_destroy(self);
  }
void hit_list_print_list(hit_list *self,FILE *stream){
    HIT_LIST_print(self, stream, NULL);
  }
hit *hit_list_get_hit(hit_list *self,ULINT i){
    return HIT_LIST_get_hit(self, i);
  }
seqn *hit_list_get_query(hit_list *self){
    seqn *Fseq;
    
    Fseq = mallocec(sizeof(seqn));
    Fseq->seq = bioseq_copy(self->query);
    Fseq->free_flag = 1;
    Fseq->defline_flag = 1;
    return Fseq;
  }
void hit_list_Z_scores(hit_list *self){
    HIT_LIST_Zscores(self);
  }
void hit_list_sort_decr(hit_list *self){
    HIT_LIST_sort_decr(self);
  }
void hit_list_sort_incr(hit_list *self){
    HIT_LIST_sort_incr(self);
  }
void hit_list_sort_by_seq(hit_list *self){
    HIT_LIST_sort_by_sequence(self);
  }
void hit_list_sort_by_oc(hit_list *self){
    HIT_LIST_sort_oc(self); 
  }
void hit_list_sort_by_evalue(hit_list *self){
    HIT_LIST_sort_evalue(self, 0);    
  }
void hit_list_sort_by_cratio(hit_list *self){
    HIT_LIST_sort_cratio(self, 0);  
  }
void hit_list_sort_by_kwscore(hit_list *self){
    HIT_LIST_sort_kwscore(self, 0);
  }
index *new_index(char const *database,ULINT flen,char const *abet,int skip){
    return FS_INDEX_create(database, flen, abet, '#', skip);
  }
void delete_index(index *self){
    FS_INDEX_destroy(self);
  }
void index_save(index *self,char const *filename){
    FS_INDEX_save(self, filename);
  }
void index_print_stats(index *self,int options,FILE *stream){
    FS_INDEX_print_stats(self, stream, options);
  }
void index_print_bin(index *self,seqn *Fseq,int options,FILE *stream){
    FS_INDEX_print_bin(self, Fseq->seq, stream, options);
  }
ULINT index_get_bin_size(index *self,ULINT bin){
    return FS_INDEX_get_bin_size(self, bin); 
  }
ULINT index_get_unique_bin_size(index *self,ULINT bin){
    return FS_INDEX_get_unique_bin_size(self, bin);
  }
seqn *index_get_seq(index *self,ULINT bin,ULINT i){
    seqn *Fseq;
    
    Fseq = mallocec(sizeof(seqn));
    Fseq->seq = bioseq_copy(FS_INDEX_get_seq(self, bin, i));
    Fseq->free_flag = 1;
    Fseq->defline_flag = 1;
    return Fseq;
  }
hit_list *index_rng_srch(index *self,seqn *query,smatrix *D,int d0){
    return FSINDX_rng_srch(self, query->seq, D, d0, NULL);
  }
hit_list *index_kNN_srch(index *self,seqn *query,smatrix *D,int k){
    return FSINDX_kNN_srch(self, query->seq, D, k, NULL);
  }
extern index *index_load(char const *);
extern hit_list *sscan_qd_srch(db *,char const *,seqn *,ULINT);
extern int sscan_has_nbr(db *,smatrix *,ptable *,seqn *,ULINT);
#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_new_seqn(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    char *arg2 ;
    seqn *result;
    
    if(!PyArg_ParseTuple(args,(char *)"ss:new_seqn",&arg1,&arg2)) goto fail;
    {
        Try {
            result = (seqn *)new_seqn(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_seqn, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_seqn(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    seqn *arg1 = (seqn *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_seqn",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            delete_seqn(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_seqn___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    seqn *arg1 = (seqn *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:seqn___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (char *)seqn___str__(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_seqn_len_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    seqn *arg1 = (seqn *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:seqn_len_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)seqn_len_get(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_seqn_seq_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    seqn *arg1 = (seqn *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:seqn_seq_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (char *)seqn_seq_get(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_seqn_defline_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    seqn *arg1 = (seqn *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:seqn_defline_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (char *)seqn_defline_get(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject * seqn_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_seqn, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_db_db_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:db_db_name_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->db_name);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db_no_seq_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:db_no_seq_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->no_seq);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_db(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    db *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_db",&arg1)) goto fail;
    {
        Try {
            result = (db *)new_db((char const *)arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_db, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_db(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_db",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            delete_db(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:db___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (char *)db___str__(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    free(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db_get_seq(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    ULINT arg2 ;
    seqn *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:db_get_seq",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (seqn *)db_get_seq(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_seqn, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db_init_frags(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    ULINT arg2 ;
    ULINT arg3 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:db_init_frags",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (ULINT) PyInt_AsLong(obj2);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            db_init_frags(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db_clear_frags(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:db_clear_frags",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            db_clear_frags(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db_get_nofrags(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    ULINT arg2 ;
    ULINT arg3 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:db_get_nofrags",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (ULINT) PyInt_AsLong(obj2);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (ULINT)db_get_nofrags(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db_get_frag(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    ULINT arg2 ;
    ULINT arg3 ;
    ULINT arg4 ;
    seqn *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOO:db_get_frag",&obj0,&obj1,&obj2,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (ULINT) PyInt_AsLong(obj2);
    if (PyErr_Occurred()) SWIG_fail;
    arg4 = (ULINT) PyInt_AsLong(obj3);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (seqn *)db_get_frag(arg1,arg2,arg3,arg4);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_seqn, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db_init_Ffrags(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    ULINT arg2 ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:db_init_Ffrags",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            db_init_Ffrags(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db_count_Ffrags(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    ULINT arg2 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:db_count_Ffrags",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (ULINT)db_count_Ffrags(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_db_get_Ffrag(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    ULINT arg2 ;
    ULINT arg3 ;
    seqn *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:db_get_Ffrag",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (ULINT) PyInt_AsLong(obj2);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (seqn *)db_get_Ffrag(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_seqn, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * db_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_db, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_new_ptable(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    ptable *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:new_ptable",&arg1)) goto fail;
    {
        Try {
            result = (ptable *)new_ptable((char const *)arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ptable, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_ptable(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_ptable",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            delete_ptable(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_print_table(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    FILE *arg2 = (FILE *) stdout ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|O:ptable_print_table",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj1) {
        {
            arg2 = PyFile_AsFile(obj1);
        }
    }
    {
        Try {
            ptable_print_table(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable___str__(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ptable___str__",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (char *)ptable___str__(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_no_pttn_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:ptable_no_pttn_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)ptable_no_pttn_get(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_get_pttn(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    char arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oc:ptable_get_pttn",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)ptable_get_pttn(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_get_posn(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    char arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oc:ptable_get_posn",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)ptable_get_posn(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_get_pttn_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    int arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ptable_get_pttn_size",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)ptable_get_pttn_size(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_get_poffset(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    int arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oi:ptable_get_poffset",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)ptable_get_poffset(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_get_letter(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    int arg2 ;
    int arg3 ;
    char result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oii:ptable_get_letter",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (char)ptable_get_letter(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = Py_BuildValue((char*)"c",result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_check_seqn(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    seqn *arg2 = (seqn *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ptable_check_seqn",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)ptable_check_seqn(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_write(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    FILE *arg2 = (FILE *) stdout ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|O:ptable_write",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj1) {
        {
            arg2 = PyFile_AsFile(obj1);
        }
    }
    {
        Try {
            ptable_write(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_ptable_seqn2reduced(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    ptable *arg1 = (ptable *) 0 ;
    seqn *arg2 = (seqn *) 0 ;
    seqn *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:ptable_seqn2reduced",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (seqn *)ptable_seqn2reduced(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_seqn, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * ptable_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_ptable, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_ptable_read(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    FILE *arg1 = (FILE *) stdin ;
    ptable *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"|O:ptable_read",&obj0)) goto fail;
    if (obj0) {
        {
            arg1 = PyFile_AsFile(obj0);
        }
    }
    {
        Try {
            result = (ptable *)ptable_read(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ptable, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fgen_max_len_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fgen *arg1 = (fgen *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:fgen_max_len_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fgen,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->max_len);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_fgen(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    ptable *arg2 = (ptable *) 0 ;
    ULINT arg3 = (ULINT) 30 ;
    fgen *result;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sO|O:new_fgen",&arg1,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj2) {
        arg3 = (ULINT) PyInt_AsLong(obj2);
        if (PyErr_Occurred()) SWIG_fail;
    }
    {
        Try {
            result = (fgen *)new_fgen((char const *)arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_fgen, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_fgen(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fgen *arg1 = (fgen *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_fgen",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fgen,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            delete_fgen(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fgen_rand_seq(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fgen *arg1 = (fgen *) 0 ;
    ULINT arg2 ;
    seqn *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:fgen_rand_seq",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fgen,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (seqn *)fgen_rand_seq(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_seqn, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_fgen_freq(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    fgen *arg1 = (fgen *) 0 ;
    char arg2 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oc:fgen_freq",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_fgen,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (double)fgen_freq(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * fgen_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_fgen, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_smatrix_filename_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:smatrix_filename_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->filename);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_similarity_flag_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:smatrix_similarity_flag_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->similarity_flag);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_smatrix(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    ptable *arg2 = (ptable *) 0 ;
    smatrix *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sO:new_smatrix",&arg1,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (smatrix *)new_smatrix((char const *)arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_smatrix, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_smatrix(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_smatrix",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            delete_smatrix(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_set_M(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    char arg2 ;
    char arg3 ;
    SSINT arg4 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Occh:smatrix_set_M",&obj0,&arg2,&arg3,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            smatrix_set_M(arg1,arg2,arg3,arg4);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_set_SS(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    char arg2 ;
    SSINT arg3 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Och:smatrix_set_SS",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            smatrix_set_SS(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_get_M(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    char arg2 ;
    char arg3 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Occ:smatrix_get_M",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)smatrix_get_M(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_get_pM(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    char arg2 ;
    int arg3 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oci:smatrix_get_pM",&obj0,&arg2,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)smatrix_get_pM(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_get_pMc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    char arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oc:smatrix_get_pMc",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)smatrix_get_pMc(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_get_SS(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    char arg2 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Oc:smatrix_get_SS",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)smatrix_get_SS(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_score(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    seqn *arg2 = (seqn *) 0 ;
    seqn *arg3 = (seqn *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:smatrix_score",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (int)smatrix_score(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_print_matrix(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    FILE *arg2 = (FILE *) stdout ;
    char *arg3 = (char *) "SCORE MATRIX" ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|Os:smatrix_print_matrix",&obj0,&obj1,&arg3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj1) {
        {
            arg2 = PyFile_AsFile(obj1);
        }
    }
    {
        Try {
            smatrix_print_matrix(arg1,arg2,(char const *)arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_S2Dmax(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    smatrix *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:smatrix_S2Dmax",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (smatrix *)smatrix_S2Dmax(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_smatrix, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_S2Davg(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    smatrix *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:smatrix_S2Davg",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (smatrix *)smatrix_S2Davg(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_smatrix, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_smatrix_S2Dquasi(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    smatrix *arg1 = (smatrix *) 0 ;
    smatrix *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:smatrix_S2Dquasi",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (smatrix *)smatrix_S2Dquasi(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_smatrix, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * smatrix_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_smatrix, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_hit_sequence_id_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_sequence_id_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->sequence_id);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_sequence_from_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_sequence_from_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->sequence_from);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_rejected_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_rejected_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->rejected);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_value_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    float result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_value_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (float) ((arg1)->value);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_pvalue_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_pvalue_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->pvalue);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_evalue_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_evalue_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->evalue);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_zvalue_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_zvalue_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->zvalue);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_oc_cluster_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_oc_cluster_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->oc_cluster);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_cratio_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_cratio_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->cratio);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_kw_score_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_kw_score_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->kw_score);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_get_subject(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit *arg1 = (hit *) 0 ;
    seqn *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_get_subject",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (seqn *)hit_get_subject(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_seqn, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * hit_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_hit, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_hit_list_frag_len_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_frag_len_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->frag_len);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_s_db_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    db *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_s_db_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (db *) ((arg1)->s_db);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_db, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_matrix_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_matrix_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->matrix);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_range_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_range_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->range);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_converted_range_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_converted_range_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->converted_range);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_kNN_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_kNN_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->kNN);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_index_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_index_name_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->index_name);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_alphabet_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_alphabet_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->alphabet);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_FS_seqs_total_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_FS_seqs_total_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->FS_seqs_total);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_FS_seqs_visited_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_FS_seqs_visited_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->FS_seqs_visited);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_FS_seqs_hits_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_FS_seqs_hits_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->FS_seqs_hits);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_index_seqs_total_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_index_seqs_total_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->index_seqs_total);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_seqs_visited_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_seqs_visited_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->seqs_visited);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_seqs_hits_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_seqs_hits_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->seqs_hits);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_useqs_visited_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_useqs_visited_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->useqs_visited);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_useqs_hits_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_useqs_hits_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->useqs_hits);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_start_time_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_start_time_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->start_time);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_end_time_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_end_time_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->end_time);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_search_time_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_search_time_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->search_time);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_max_hits_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_max_hits_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->max_hits);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_actual_seqs_hits_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_actual_seqs_hits_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->actual_seqs_hits);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_accepted_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_accepted_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->accepted);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_shape_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_shape_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->shape);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_rate_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_rate_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->rate);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_Zmin_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    double result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_Zmin_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (double) ((arg1)->Zmin);
    
    resultobj = PyFloat_FromDouble(result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_hit_list(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_hit_list",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            delete_hit_list(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_print_list(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    FILE *arg2 = (FILE *) stdout ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|O:hit_list_print_list",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj1) {
        {
            arg2 = PyFile_AsFile(obj1);
        }
    }
    {
        Try {
            hit_list_print_list(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_get_hit(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    ULINT arg2 ;
    hit *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:hit_list_get_hit",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (hit *)hit_list_get_hit(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_hit, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_get_query(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    seqn *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_get_query",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (seqn *)hit_list_get_query(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_seqn, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_Z_scores(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_Z_scores",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            hit_list_Z_scores(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_sort_decr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_sort_decr",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            hit_list_sort_decr(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_sort_incr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_sort_incr",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            hit_list_sort_incr(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_sort_by_seq(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_sort_by_seq",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            hit_list_sort_by_seq(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_sort_by_oc(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_sort_by_oc",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            hit_list_sort_by_oc(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_sort_by_evalue(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_sort_by_evalue",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            hit_list_sort_by_evalue(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_sort_by_cratio(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_sort_by_cratio",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            hit_list_sort_by_cratio(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_hit_list_sort_by_kwscore(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    hit_list *arg1 = (hit_list *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:hit_list_sort_by_kwscore",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_hit_list,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            hit_list_sort_by_kwscore(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject * hit_list_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_hit_list, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_index_db_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:index_db_name_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->db_name);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_index_name_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    char *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:index_index_name_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (char *) ((arg1)->index_name);
    
    resultobj = result ? PyString_FromString(result) : Py_BuildValue((char*)"");
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_s_db_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    db *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:index_s_db_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (db *) ((arg1)->s_db);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_db, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_ptable_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    ptable *result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:index_ptable_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ptable *) ((arg1)->ptable);
    
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_ptable, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_m_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    int result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:index_m_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (int) ((arg1)->m);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_db_no_frags_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:index_db_no_frags_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->db_no_frags);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_no_bins_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:index_no_bins_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->no_bins);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_no_seqs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:index_no_seqs_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->no_seqs);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_no_useqs_get(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:index_no_useqs_get",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    result = (ULINT) ((arg1)->no_useqs);
    
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_new_index(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    ULINT arg2 ;
    char *arg3 ;
    int arg4 = (int) 1 ;
    index *result;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"sOs|i:new_index",&arg1,&obj1,&arg3,&arg4)) goto fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (index *)new_index((char const *)arg1,arg2,(char const *)arg3,arg4);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_index, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_delete_index(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O:delete_index",&obj0)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            delete_index(arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_save(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    char *arg2 ;
    PyObject * obj0 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"Os:index_save",&obj0,&arg2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            index_save(arg1,(char const *)arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_print_stats(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    int arg2 = (int) 3 ;
    FILE *arg3 = (FILE *) stdout ;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"O|iO:index_print_stats",&obj0,&arg2,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj2) {
        {
            arg3 = PyFile_AsFile(obj2);
        }
    }
    {
        Try {
            index_print_stats(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_print_bin(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    seqn *arg2 = (seqn *) 0 ;
    int arg3 = (int) 1 ;
    FILE *arg4 = (FILE *) stdout ;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO|iO:index_print_bin",&obj0,&obj1,&arg3,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if (obj3) {
        {
            arg4 = PyFile_AsFile(obj3);
        }
    }
    {
        Try {
            index_print_bin(arg1,arg2,arg3,arg4);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    Py_INCREF(Py_None); resultobj = Py_None;
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_get_bin_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    ULINT arg2 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:index_get_bin_size",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (ULINT)index_get_bin_size(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_get_unique_bin_size(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    ULINT arg2 ;
    ULINT result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OO:index_get_unique_bin_size",&obj0,&obj1)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (ULINT)index_get_unique_bin_size(arg1,arg2);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_get_seq(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    ULINT arg2 ;
    ULINT arg3 ;
    seqn *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOO:index_get_seq",&obj0,&obj1,&obj2)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg2 = (ULINT) PyInt_AsLong(obj1);
    if (PyErr_Occurred()) SWIG_fail;
    arg3 = (ULINT) PyInt_AsLong(obj2);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (seqn *)index_get_seq(arg1,arg2,arg3);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_seqn, 1);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_rng_srch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    seqn *arg2 = (seqn *) 0 ;
    smatrix *arg3 = (smatrix *) 0 ;
    int arg4 ;
    hit_list *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOi:index_rng_srch",&obj0,&obj1,&obj2,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (hit_list *)index_rng_srch(arg1,arg2,arg3,arg4);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_hit_list, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_index_kNN_srch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    index *arg1 = (index *) 0 ;
    seqn *arg2 = (seqn *) 0 ;
    smatrix *arg3 = (smatrix *) 0 ;
    int arg4 ;
    hit_list *result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOi:index_kNN_srch",&obj0,&obj1,&obj2,&arg4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_index,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    {
        Try {
            result = (hit_list *)index_kNN_srch(arg1,arg2,arg3,arg4);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_hit_list, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject * index_swigregister(PyObject *self, PyObject *args) {
    PyObject *obj;
    if (!PyArg_ParseTuple(args,(char*)"O", &obj)) return NULL;
    SWIG_TypeClientData(SWIGTYPE_p_index, obj);
    Py_INCREF(obj);
    return Py_BuildValue((char *)"");
}
static PyObject *_wrap_index_load(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    char *arg1 ;
    index *result;
    
    if(!PyArg_ParseTuple(args,(char *)"s:index_load",&arg1)) goto fail;
    {
        Try {
            result = (index *)index_load((char const *)arg1);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_index, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_sscan_qd_srch(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    char *arg2 ;
    seqn *arg3 = (seqn *) 0 ;
    ULINT arg4 ;
    hit_list *result;
    PyObject * obj0 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OsOO:sscan_qd_srch",&obj0,&arg2,&obj2,&obj3)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg4 = (ULINT) PyInt_AsLong(obj3);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (hit_list *)sscan_qd_srch(arg1,(char const *)arg2,arg3,arg4);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_hit_list, 0);
    return resultobj;
    fail:
    return NULL;
}


static PyObject *_wrap_sscan_has_nbr(PyObject *self, PyObject *args) {
    PyObject *resultobj;
    db *arg1 = (db *) 0 ;
    smatrix *arg2 = (smatrix *) 0 ;
    ptable *arg3 = (ptable *) 0 ;
    seqn *arg4 = (seqn *) 0 ;
    ULINT arg5 ;
    int result;
    PyObject * obj0 = 0 ;
    PyObject * obj1 = 0 ;
    PyObject * obj2 = 0 ;
    PyObject * obj3 = 0 ;
    PyObject * obj4 = 0 ;
    
    if(!PyArg_ParseTuple(args,(char *)"OOOOO:sscan_has_nbr",&obj0,&obj1,&obj2,&obj3,&obj4)) goto fail;
    if ((SWIG_ConvertPtr(obj0,(void **) &arg1, SWIGTYPE_p_db,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj1,(void **) &arg2, SWIGTYPE_p_smatrix,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj2,(void **) &arg3, SWIGTYPE_p_ptable,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    if ((SWIG_ConvertPtr(obj3,(void **) &arg4, SWIGTYPE_p_seqn,SWIG_POINTER_EXCEPTION | 0 )) == -1) SWIG_fail;
    arg5 = (ULINT) PyInt_AsLong(obj4);
    if (PyErr_Occurred()) SWIG_fail;
    {
        Try {
            result = (int)sscan_has_nbr(arg1,arg2,arg3,arg4,arg5);
            
        }
        Catch(except) {
            switch (except->code)
            {
                case NO_ERR:
                break;
                case NO_MEM:
                PyErr_SetString(PyExc_MemoryError, except->msg);
                break;
                case NEG_MEM_REQ:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case FOPEN_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case FCLOSE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case BAD_ARGS:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
                case EOF_REACHED:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case GETLINE_ERR:
                PyErr_SetString(PyExc_IOError, except->msg);
                break;
                case INDEX_OUT_OF_RANGE:
                PyErr_SetString(PyExc_IndexError, except->msg);
                break;
                default:
                PyErr_SetString(PyExc_RuntimeError, except->msg);
                break;
            }
            return NULL;
        }
    }
    resultobj = PyInt_FromLong((long)result);
    return resultobj;
    fail:
    return NULL;
}


static PyMethodDef SwigMethods[] = {
	 { (char *)"new_seqn", _wrap_new_seqn, METH_VARARGS },
	 { (char *)"delete_seqn", _wrap_delete_seqn, METH_VARARGS },
	 { (char *)"seqn___str__", _wrap_seqn___str__, METH_VARARGS },
	 { (char *)"seqn_len_get", _wrap_seqn_len_get, METH_VARARGS },
	 { (char *)"seqn_seq_get", _wrap_seqn_seq_get, METH_VARARGS },
	 { (char *)"seqn_defline_get", _wrap_seqn_defline_get, METH_VARARGS },
	 { (char *)"seqn_swigregister", seqn_swigregister, METH_VARARGS },
	 { (char *)"db_db_name_get", _wrap_db_db_name_get, METH_VARARGS },
	 { (char *)"db_no_seq_get", _wrap_db_no_seq_get, METH_VARARGS },
	 { (char *)"new_db", _wrap_new_db, METH_VARARGS },
	 { (char *)"delete_db", _wrap_delete_db, METH_VARARGS },
	 { (char *)"db___str__", _wrap_db___str__, METH_VARARGS },
	 { (char *)"db_get_seq", _wrap_db_get_seq, METH_VARARGS },
	 { (char *)"db_init_frags", _wrap_db_init_frags, METH_VARARGS },
	 { (char *)"db_clear_frags", _wrap_db_clear_frags, METH_VARARGS },
	 { (char *)"db_get_nofrags", _wrap_db_get_nofrags, METH_VARARGS },
	 { (char *)"db_get_frag", _wrap_db_get_frag, METH_VARARGS },
	 { (char *)"db_init_Ffrags", _wrap_db_init_Ffrags, METH_VARARGS },
	 { (char *)"db_count_Ffrags", _wrap_db_count_Ffrags, METH_VARARGS },
	 { (char *)"db_get_Ffrag", _wrap_db_get_Ffrag, METH_VARARGS },
	 { (char *)"db_swigregister", db_swigregister, METH_VARARGS },
	 { (char *)"new_ptable", _wrap_new_ptable, METH_VARARGS },
	 { (char *)"delete_ptable", _wrap_delete_ptable, METH_VARARGS },
	 { (char *)"ptable_print_table", _wrap_ptable_print_table, METH_VARARGS },
	 { (char *)"ptable___str__", _wrap_ptable___str__, METH_VARARGS },
	 { (char *)"ptable_no_pttn_get", _wrap_ptable_no_pttn_get, METH_VARARGS },
	 { (char *)"ptable_get_pttn", _wrap_ptable_get_pttn, METH_VARARGS },
	 { (char *)"ptable_get_posn", _wrap_ptable_get_posn, METH_VARARGS },
	 { (char *)"ptable_get_pttn_size", _wrap_ptable_get_pttn_size, METH_VARARGS },
	 { (char *)"ptable_get_poffset", _wrap_ptable_get_poffset, METH_VARARGS },
	 { (char *)"ptable_get_letter", _wrap_ptable_get_letter, METH_VARARGS },
	 { (char *)"ptable_check_seqn", _wrap_ptable_check_seqn, METH_VARARGS },
	 { (char *)"ptable_write", _wrap_ptable_write, METH_VARARGS },
	 { (char *)"ptable_seqn2reduced", _wrap_ptable_seqn2reduced, METH_VARARGS },
	 { (char *)"ptable_swigregister", ptable_swigregister, METH_VARARGS },
	 { (char *)"ptable_read", _wrap_ptable_read, METH_VARARGS },
	 { (char *)"fgen_max_len_get", _wrap_fgen_max_len_get, METH_VARARGS },
	 { (char *)"new_fgen", _wrap_new_fgen, METH_VARARGS },
	 { (char *)"delete_fgen", _wrap_delete_fgen, METH_VARARGS },
	 { (char *)"fgen_rand_seq", _wrap_fgen_rand_seq, METH_VARARGS },
	 { (char *)"fgen_freq", _wrap_fgen_freq, METH_VARARGS },
	 { (char *)"fgen_swigregister", fgen_swigregister, METH_VARARGS },
	 { (char *)"smatrix_filename_get", _wrap_smatrix_filename_get, METH_VARARGS },
	 { (char *)"smatrix_similarity_flag_get", _wrap_smatrix_similarity_flag_get, METH_VARARGS },
	 { (char *)"new_smatrix", _wrap_new_smatrix, METH_VARARGS },
	 { (char *)"delete_smatrix", _wrap_delete_smatrix, METH_VARARGS },
	 { (char *)"smatrix_set_M", _wrap_smatrix_set_M, METH_VARARGS },
	 { (char *)"smatrix_set_SS", _wrap_smatrix_set_SS, METH_VARARGS },
	 { (char *)"smatrix_get_M", _wrap_smatrix_get_M, METH_VARARGS },
	 { (char *)"smatrix_get_pM", _wrap_smatrix_get_pM, METH_VARARGS },
	 { (char *)"smatrix_get_pMc", _wrap_smatrix_get_pMc, METH_VARARGS },
	 { (char *)"smatrix_get_SS", _wrap_smatrix_get_SS, METH_VARARGS },
	 { (char *)"smatrix_score", _wrap_smatrix_score, METH_VARARGS },
	 { (char *)"smatrix_print_matrix", _wrap_smatrix_print_matrix, METH_VARARGS },
	 { (char *)"smatrix_S2Dmax", _wrap_smatrix_S2Dmax, METH_VARARGS },
	 { (char *)"smatrix_S2Davg", _wrap_smatrix_S2Davg, METH_VARARGS },
	 { (char *)"smatrix_S2Dquasi", _wrap_smatrix_S2Dquasi, METH_VARARGS },
	 { (char *)"smatrix_swigregister", smatrix_swigregister, METH_VARARGS },
	 { (char *)"hit_sequence_id_get", _wrap_hit_sequence_id_get, METH_VARARGS },
	 { (char *)"hit_sequence_from_get", _wrap_hit_sequence_from_get, METH_VARARGS },
	 { (char *)"hit_rejected_get", _wrap_hit_rejected_get, METH_VARARGS },
	 { (char *)"hit_value_get", _wrap_hit_value_get, METH_VARARGS },
	 { (char *)"hit_pvalue_get", _wrap_hit_pvalue_get, METH_VARARGS },
	 { (char *)"hit_evalue_get", _wrap_hit_evalue_get, METH_VARARGS },
	 { (char *)"hit_zvalue_get", _wrap_hit_zvalue_get, METH_VARARGS },
	 { (char *)"hit_oc_cluster_get", _wrap_hit_oc_cluster_get, METH_VARARGS },
	 { (char *)"hit_cratio_get", _wrap_hit_cratio_get, METH_VARARGS },
	 { (char *)"hit_kw_score_get", _wrap_hit_kw_score_get, METH_VARARGS },
	 { (char *)"hit_get_subject", _wrap_hit_get_subject, METH_VARARGS },
	 { (char *)"hit_swigregister", hit_swigregister, METH_VARARGS },
	 { (char *)"hit_list_frag_len_get", _wrap_hit_list_frag_len_get, METH_VARARGS },
	 { (char *)"hit_list_s_db_get", _wrap_hit_list_s_db_get, METH_VARARGS },
	 { (char *)"hit_list_matrix_get", _wrap_hit_list_matrix_get, METH_VARARGS },
	 { (char *)"hit_list_range_get", _wrap_hit_list_range_get, METH_VARARGS },
	 { (char *)"hit_list_converted_range_get", _wrap_hit_list_converted_range_get, METH_VARARGS },
	 { (char *)"hit_list_kNN_get", _wrap_hit_list_kNN_get, METH_VARARGS },
	 { (char *)"hit_list_index_name_get", _wrap_hit_list_index_name_get, METH_VARARGS },
	 { (char *)"hit_list_alphabet_get", _wrap_hit_list_alphabet_get, METH_VARARGS },
	 { (char *)"hit_list_FS_seqs_total_get", _wrap_hit_list_FS_seqs_total_get, METH_VARARGS },
	 { (char *)"hit_list_FS_seqs_visited_get", _wrap_hit_list_FS_seqs_visited_get, METH_VARARGS },
	 { (char *)"hit_list_FS_seqs_hits_get", _wrap_hit_list_FS_seqs_hits_get, METH_VARARGS },
	 { (char *)"hit_list_index_seqs_total_get", _wrap_hit_list_index_seqs_total_get, METH_VARARGS },
	 { (char *)"hit_list_seqs_visited_get", _wrap_hit_list_seqs_visited_get, METH_VARARGS },
	 { (char *)"hit_list_seqs_hits_get", _wrap_hit_list_seqs_hits_get, METH_VARARGS },
	 { (char *)"hit_list_useqs_visited_get", _wrap_hit_list_useqs_visited_get, METH_VARARGS },
	 { (char *)"hit_list_useqs_hits_get", _wrap_hit_list_useqs_hits_get, METH_VARARGS },
	 { (char *)"hit_list_start_time_get", _wrap_hit_list_start_time_get, METH_VARARGS },
	 { (char *)"hit_list_end_time_get", _wrap_hit_list_end_time_get, METH_VARARGS },
	 { (char *)"hit_list_search_time_get", _wrap_hit_list_search_time_get, METH_VARARGS },
	 { (char *)"hit_list_max_hits_get", _wrap_hit_list_max_hits_get, METH_VARARGS },
	 { (char *)"hit_list_actual_seqs_hits_get", _wrap_hit_list_actual_seqs_hits_get, METH_VARARGS },
	 { (char *)"hit_list_accepted_get", _wrap_hit_list_accepted_get, METH_VARARGS },
	 { (char *)"hit_list_shape_get", _wrap_hit_list_shape_get, METH_VARARGS },
	 { (char *)"hit_list_rate_get", _wrap_hit_list_rate_get, METH_VARARGS },
	 { (char *)"hit_list_Zmin_get", _wrap_hit_list_Zmin_get, METH_VARARGS },
	 { (char *)"delete_hit_list", _wrap_delete_hit_list, METH_VARARGS },
	 { (char *)"hit_list_print_list", _wrap_hit_list_print_list, METH_VARARGS },
	 { (char *)"hit_list_get_hit", _wrap_hit_list_get_hit, METH_VARARGS },
	 { (char *)"hit_list_get_query", _wrap_hit_list_get_query, METH_VARARGS },
	 { (char *)"hit_list_Z_scores", _wrap_hit_list_Z_scores, METH_VARARGS },
	 { (char *)"hit_list_sort_decr", _wrap_hit_list_sort_decr, METH_VARARGS },
	 { (char *)"hit_list_sort_incr", _wrap_hit_list_sort_incr, METH_VARARGS },
	 { (char *)"hit_list_sort_by_seq", _wrap_hit_list_sort_by_seq, METH_VARARGS },
	 { (char *)"hit_list_sort_by_oc", _wrap_hit_list_sort_by_oc, METH_VARARGS },
	 { (char *)"hit_list_sort_by_evalue", _wrap_hit_list_sort_by_evalue, METH_VARARGS },
	 { (char *)"hit_list_sort_by_cratio", _wrap_hit_list_sort_by_cratio, METH_VARARGS },
	 { (char *)"hit_list_sort_by_kwscore", _wrap_hit_list_sort_by_kwscore, METH_VARARGS },
	 { (char *)"hit_list_swigregister", hit_list_swigregister, METH_VARARGS },
	 { (char *)"index_db_name_get", _wrap_index_db_name_get, METH_VARARGS },
	 { (char *)"index_index_name_get", _wrap_index_index_name_get, METH_VARARGS },
	 { (char *)"index_s_db_get", _wrap_index_s_db_get, METH_VARARGS },
	 { (char *)"index_ptable_get", _wrap_index_ptable_get, METH_VARARGS },
	 { (char *)"index_m_get", _wrap_index_m_get, METH_VARARGS },
	 { (char *)"index_db_no_frags_get", _wrap_index_db_no_frags_get, METH_VARARGS },
	 { (char *)"index_no_bins_get", _wrap_index_no_bins_get, METH_VARARGS },
	 { (char *)"index_no_seqs_get", _wrap_index_no_seqs_get, METH_VARARGS },
	 { (char *)"index_no_useqs_get", _wrap_index_no_useqs_get, METH_VARARGS },
	 { (char *)"new_index", _wrap_new_index, METH_VARARGS },
	 { (char *)"delete_index", _wrap_delete_index, METH_VARARGS },
	 { (char *)"index_save", _wrap_index_save, METH_VARARGS },
	 { (char *)"index_print_stats", _wrap_index_print_stats, METH_VARARGS },
	 { (char *)"index_print_bin", _wrap_index_print_bin, METH_VARARGS },
	 { (char *)"index_get_bin_size", _wrap_index_get_bin_size, METH_VARARGS },
	 { (char *)"index_get_unique_bin_size", _wrap_index_get_unique_bin_size, METH_VARARGS },
	 { (char *)"index_get_seq", _wrap_index_get_seq, METH_VARARGS },
	 { (char *)"index_rng_srch", _wrap_index_rng_srch, METH_VARARGS },
	 { (char *)"index_kNN_srch", _wrap_index_kNN_srch, METH_VARARGS },
	 { (char *)"index_swigregister", index_swigregister, METH_VARARGS },
	 { (char *)"index_load", _wrap_index_load, METH_VARARGS },
	 { (char *)"sscan_qd_srch", _wrap_sscan_qd_srch, METH_VARARGS },
	 { (char *)"sscan_has_nbr", _wrap_sscan_has_nbr, METH_VARARGS },
	 { NULL, NULL }
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_FILE[] = {{"_p_FILE", 0, "FILE *", 0},{"_p_FILE"},{0}};
static swig_type_info _swigt__p_index[] = {{"_p_index", 0, "index *", 0},{"_p_index"},{0}};
static swig_type_info _swigt__p_fgen[] = {{"_p_fgen", 0, "fgen *", 0},{"_p_fgen"},{0}};
static swig_type_info _swigt__p_seqn[] = {{"_p_seqn", 0, "seqn *", 0},{"_p_seqn"},{0}};
static swig_type_info _swigt__p_smatrix[] = {{"_p_smatrix", 0, "smatrix *", 0},{"_p_smatrix"},{0}};
static swig_type_info _swigt__p_db[] = {{"_p_db", 0, "db *", 0},{"_p_db"},{0}};
static swig_type_info _swigt__p_hit[] = {{"_p_hit", 0, "hit *", 0},{"_p_hit"},{0}};
static swig_type_info _swigt__p_hit_list[] = {{"_p_hit_list", 0, "hit_list *", 0},{"_p_hit_list"},{0}};
static swig_type_info _swigt__p_ptable[] = {{"_p_ptable", 0, "ptable *", 0},{"_p_ptable"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_FILE, 
_swigt__p_index, 
_swigt__p_fgen, 
_swigt__p_seqn, 
_swigt__p_smatrix, 
_swigt__p_db, 
_swigt__p_hit, 
_swigt__p_hit_list, 
_swigt__p_ptable, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
{0}};

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT(void) SWIG_init(void) {
    static PyObject *SWIG_globals = 0; 
    static int       typeinit = 0;
    PyObject *m, *d;
    int       i;
    if (!SWIG_globals) SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule((char *) SWIG_name, SwigMethods);
    d = PyModule_GetDict(m);
    
    if (!typeinit) {
        for (i = 0; swig_types_initial[i]; i++) {
            swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        }
        typeinit = 1;
    }
    SWIG_InstallConstants(d,swig_const_table);
    
}

